<!-- TOC -->

- [简介](#简介)
- [文件分为几种形态](#文件分为几种形态)
- [ClassLoader类加载器](#ClassLoader类加载器)
    - [如何把内加载器加载到指定的区域中？](#如何把内加载器加载到指定的区域中？)
    - [核心原理是什么？](#核心原理是什么？)
    - [它是怎么把内加载器加载到内存中的？](#它是怎么把内加载器加载到内存中的？)
- [双亲委派](#双亲委派)
    - [双亲委派模式工作原理？](#双亲委派模式工作原理？)
    - [类加载器间的关系？](#类加载器间的关系？)
    - [双亲委派模式优势？](#双亲委派模式优势？)
- [扩展](#扩展)
    - [部析源码](#部析源码)
    - [加载过程](#加载过程)
    - [总结知识要点](#总结知识要点)
- [运行时数据区](#运行时数据区)
    - [Java堆](#Java堆)
    - [方法区](#方法区)
    - [栈](#栈)
    - [代码演示](#代码演示)

<!-- TOC -->

## 简介

- JVM类加载器:ClassLoader

加载指的是将类的class文件读入到内存，并为之创建一个java.lang.Class对象，也就是说，当程序中使用任何类时，系统都会为之建立一个java.lang.Class对象。

类的加载由类加载器完成，类加载器通常由JVM提供，这些类加载器也是前面所有程序运行的基础，JVM提供的这些类加载器通常被称为系统类加载器。除此之外，开发者可以通过继承ClassLoader基类来创建自己的类加载器。

![JVM类加载器](https://i.loli.net/2019/07/03/5d1ca4e6bc61172562.png)

## 文件分为几种形态

    java文件分为几种形态?
    2种：静态、动态
    
- Source、Class二进制字节码——》静态

- Java文件在内存中运行的形态——》动态

## ClassLoader类加载器

首先了解一下类加载的流程是什么！

### 如何把内加载器加载到指定的区域中？

![类加载的过程](https://i.loli.net/2019/07/04/5d1db5b0839d739592.png)

### 核心原理是什么？

### 它是怎么把内加载器加载到内存中的？

## 双亲委派

### 双亲委派模式工作原理？

双亲委派模式要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器，请注意双亲委派模式中的父子关系并非通常所说的类继承关系，而是采用组合关系来复用父类加载器的相关代码。
![](https://i.loli.net/2019/07/04/5d1dba8c0578898053.png)<br>
注：图片来源于网络:https://blog.csdn.net/javazejian

### 类加载器间的关系？

双亲委派模式是在Java 1.2后引入的，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，
如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式，即每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己想办法去完成。

### 双亲委派模式优势？

采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。
其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。

双亲委派图：
![双亲委派图](https://i.loli.net/2019/07/04/5d1db85d7663557061.png)

## 扩展
### 部析源码
![源码](https://i.loli.net/2019/07/03/5d1ca3485322194295.png)

### 加载过程

加载：通过一个类的完全限定查找此类字节码文件，并利用字节码文件创建一个Class对象

验证：目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身安全。

准备：为类变量分配内存并且设置该类变量的初始值即0，这里不包含用final修饰的static，因为final在编译的时候就会分配了，注意这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中。

解析：主要将常量池中的符号引用替换为直接引用的过程。

初始化：类加载最后阶段，若该类具有超类，则对其进行初始化，执行静态初始化器和静态初始化成员变量(如前面只初始化了默认值的static变量将会在这个阶段赋值，成员变量也将被初始化)。

### 总结知识要点

## 运行时数据区

类在内存的唯一性，运行时数据区

![](https://i.loli.net/2019/07/03/5d1ca8c56275b47502.png)
```
LoadClass
    findBootStrapClassOrNull
        findBootStrapClass
```
JAVA的JVM的内存可分为3个区：堆(heap)、栈(stack)和方法区(method) 

### Java堆
JVM内存结构---》Java堆(heap)
```
堆区: 
1.存储的全部是对象，每个对象都包含一个与之对应的class的信息。(class的目的是得到操作指令) 
2.jvm只有一个堆区(heap)被所有线程共享，堆中不存放基本类型和对象引用，只存放对象本身 
```

### 方法区
JVM内存结构---》方法区(method)
```
方法区: 
1.又叫静态区，跟堆一样，被所有的线程共享。方法区包含所有的class和static变量。 
2.方法区中包含的都是在整个程序中永远唯一的元素，如class，static变量。 
为了更清楚地搞明白发生在运行时数据区里的黑幕，我们来准备2个小道具（2个非常简单的小程序）。
```

### 栈
JVM内存结构---》栈(stack)

```
栈区: 
1.每个线程包含一个栈区，栈中只保存基础数据类型的对象和自定义对象的引用(不是对象)，对象都存放在堆区中 
2.每个栈中的数据(原始类型和对象引用)都是私有的，其他栈不能访问。 
3.栈分为3个部分：基本类型变量区、执行环境上下文、操作指令区(存放操作指令)。
``` 

### 代码演示

```
public   class  AppMain                //运行时, jvm 把appmain的信息都放入方法区    
{    
public   static   void  main(String[] args)  //main 方法本身放入方法区。    
{    
Sample test1 = new  Sample( " 测试1 " );   //test1是引用，所以放到栈区里， Sample是自定义对象应该放到堆里面    
Sample test2 = new  Sample( " 测试2 " );    
 
test1.printName();    
test2.printName();    
}    
} Sample.java    
  
public   class  Sample        //运行时, jvm 把appmain的信息都放入方法区    
{    
/** 范例名称 */    
private  name;      //new Sample实例后， name 引用放入栈区里，  name 对象放入堆里    
/** 构造方法 */    
public  Sample(String name)    
{    
this .name = name;    
}    
  
/** 输出 */    
public   void  printName()   //print方法本身放入 方法区里。    
{    
System.out.println(name);    
}    
}   
```
![](https://i.loli.net/2019/07/04/5d1dbcebc6eb144876.png)

